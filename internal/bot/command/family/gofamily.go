package family

import (
	"fmt"
	"github.com/mymmrac/telego"
	tu "github.com/mymmrac/telego/telegoutil"
	"go.uber.org/zap"
	"go_tg_bot/internal/bot/callback"
	"go_tg_bot/internal/database/mongo/repositories/brak"
	"time"
)

type goFamily struct {
	cm    *callback.CallbacksManager
	braks brak.Repository
	log   *zap.Logger
}

func (g goFamily) Handle(bot *telego.Bot, update telego.Update) {
	fUser := update.Message.From
	reply := update.Message.ReplyToMessage

	if reply == nil {
		_, err := bot.SendMessage(&telego.SendMessageParams{
			ChatID: tu.ID(update.Message.Chat.ID),
			Text:   fmt.Sprintf("@%s, –æ—Ç–≤–µ—Ç—å –Ω–∞ –ª—é–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–∞—Ä—Ç–Ω—ë—Ä–∞. üòòüí¨", update.Message.From.Username),
			ReplyParameters: &telego.ReplyParameters{
				MessageID: update.Message.GetMessageID(),
			},
		})
		if err != nil {
			g.log.Sugar().Error(err)
		}
		return
	}

	tUser := reply.From
	if tUser.ID == fUser.ID {
		_, err := bot.SendMessage(&telego.SendMessageParams{
			ChatID: tu.ID(update.Message.Chat.ID),
			Text:   fmt.Sprintf("@%s, –±—Ä–∞–∫ —Å —Å–æ–±–æ–π –Ω–µ–ª—å–∑—è, –ø—Ä–∏–¥—ë—Ç—Å—è –∏—Å–∫–∞—Ç—å –ø–∞—Ä—É. üò•", update.Message.From.Username),
			ReplyParameters: &telego.ReplyParameters{
				MessageID: update.Message.GetMessageID(),
			},
		})
		if err != nil {
			g.log.Sugar().Error(err)
		}
		return
	}

	if tUser.IsBot {
		_, err := bot.SendMessage(&telego.SendMessageParams{
			ChatID: tu.ID(update.Message.Chat.ID),
			Text:   fmt.Sprintf("@%s, –±–æ—Ç–∞ –Ω–µ —Ç—Ä–æ–≥–∞–π. üëø", update.Message.From.Username),
			ReplyParameters: &telego.ReplyParameters{
				MessageID: update.Message.GetMessageID(),
			},
		})
		if err != nil {
			g.log.Sugar().Error(err)
		}
		return
	}

	fbrak, _ := g.braks.FindByUserID(fUser.ID)

	if fbrak != nil {
		_, err := bot.SendMessage(&telego.SendMessageParams{
			ChatID: tu.ID(update.Message.Chat.ID),
			Text:   fmt.Sprintf("@%s, —É –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –±—Ä–∞–∫! üíç", update.Message.From.Username),
			ReplyParameters: &telego.ReplyParameters{
				MessageID: update.Message.GetMessageID(),
			},
		})
		if err != nil {
			g.log.Sugar().Error(err)
		}
		return
	}

	tbrak, _ := g.braks.FindByUserID(tUser.ID)

	if tbrak != nil {
		_, err := bot.SendMessage(&telego.SendMessageParams{
			ChatID: tu.ID(update.Message.Chat.ID),
			Text:   fmt.Sprintf("@%s, —É –≤–∞—à–µ–≥–æ –ø–∞—Ä—Ç–Ω—ë—Ä–∞ —É–∂–µ –µ—Å—Ç—å –±—Ä–∞–∫! üíç", update.Message.From.Username),
			ReplyParameters: &telego.ReplyParameters{
				MessageID: update.Message.GetMessageID(),
			},
		})
		if err != nil {
			g.log.Sugar().Error(err)
		}
		return
	}

	yesCallback := g.cm.DynamicCallback(callback.DynamicOpts{
		Label:    "–î–∞!‚ù§Ô∏è‚Äçüî•",
		CtxType:  callback.ChooseOne,
		OwnerIDs: []int64{tUser.ID},
		Time:     time.Duration(60) * time.Minute,
		Callback: func(query telego.CallbackQuery) {
			g.braks.Insert(&brak.Brak{
				FirstUserID:  fUser.ID,
				SecondUserID: tUser.ID,
				CreateDate:   time.Now(),
				Score:        0,
			})
			_, err := bot.SendMessage(tu.Messagef(
				telego.ChatID{ID: query.Message.GetChat().ID},
				"Hello %s!", query.From.FirstName,
			))
			if err != nil {
				g.log.Sugar().Error(err)
				return
			}
		},
	})

	noCallback := g.cm.DynamicCallback(callback.DynamicOpts{
		Label:      "–ù–µ—Ç!üíî",
		CtxType:    callback.ChooseOne,
		OwnerIDs:   []int64{tUser.ID},
		Time:       time.Duration(60) * time.Minute,
		AnswerText: "–û—Ç–∫–∞–∑ üñ§",
		Callback: func(query telego.CallbackQuery) {
			_, err := bot.SendMessage(&telego.SendMessageParams{
				ChatID: tu.ID(update.Message.Chat.ID),
				Text:   "–û—Ç–∫–∞–∑ üñ§",
				ReplyParameters: &telego.ReplyParameters{
					MessageID: query.Message.GetMessageID(),
				},
			})
			if err != nil {
				g.log.Sugar().Error(err)
				return
			}
		},
	})

	from := update.Message.From
	_, _ = bot.SendMessage(
		tu.Messagef(
			tu.ID(update.Message.Chat.ID),
			"üíç @%s, –º–∏–Ω—É—Ç–æ—á–∫—É –≤–Ω–∏–º–∞–Ω–∏—è.\n"+
				"üíñ @%s —Å–¥–µ–ª–∞–ª –≤–∞–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ä—É–∫–∏ –∏ —Å–µ—Ä–¥—Ü–∞.",
			from.Username,
			from.Username,
		).WithReplyMarkup(
			tu.InlineKeyboard(
				tu.InlineKeyboardRow(
					yesCallback.Inline(),
					noCallback.Inline(),
				),
			),
		))
}
